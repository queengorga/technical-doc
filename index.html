<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="style.css">
    <title>Technical Document Page | FCC Responsive Web Design Project</title>
</head>
<body class="row">
    <main id="main-doc">
        <section class="main-section" id="javascript-nav"> <!--Minimum of 5 sections-->
                <nav id="navbar">
                    <div class="row">
                    <header><a href="#introduction"><img src="img/logo.png" alt=""></a>JavaScript</header>
                        <p>Content Source:<a class="source" target="_blank" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript"> MDN Web Docs</a></p>
                    </div>
                    <ul class="nav-bar">
                        <li><a class="nav-link" href="#introduction">Introduction</a></li>
                        <li><a class="nav-link" href="#basics-intro">Basics</a></li>
                        <li><a class="nav-link" href="#bblocks-intro">Javascript Building Blocks</a></li>
                        <li><a class="nav-link" href="#objects-intro">Javascript Objects</a></li>
                        <li><a class="nav-link" href="#client-intro">Client-side Web APIs</a></li>
                    </ul>
                </nav>
        </section>

        <section id="introduction" class="main-section">
            <div class="header-intro">
                <header>Introduction</header>
            </div>      
            <div class="container">
                <div class="row">
                    <p>JavaScript is a programming language that allows you to implement complex things on web pages. Every time a web page
                    does more than just sit there and display static information for you to look at — displaying timely content
                    updates, or interactive maps, or animated 2D/3D graphics, or scrolling video jukeboxes, and so on — you can bet
                    that JavaScript is probably involved.</p>
                    <ul>
                    <li>Conceived as a server-side language by Brendan Eich (then employed by the Netscape Corporation), JavaScript soon came
                    to Netscape Navigator 2.0 in September 1995. JavaScript enjoyed immediate success and Internet Explorer 3.0 introduced
                    JavaScript support under the name JScript in August 1996.</li>
                    <li>JavaScript is mostly used in the browser, enabling developers to manipulate webpage content through the DOM, manipulate
                    data with AJAX and IndexedDB, draw graphics with canvas, interact with the device running the browser through various
                    APIs, and so forth. JavaScript is one of the world's most commonly-used languages, owing to the recent growth and
                    performance improvement of APIs available in browsers.</li>
                    <li>Recently, JavaScript's popularity has expanded even further through the successful Node.js platform - the most popular
                    cross-platform JavaScript runtime environment outside the browser. Node.js allows developers to use JavaScript as a
                    scripting language to automate things on a PC and build fully functional HTTP and Web Sockets servers.</li>
                    </ul>
                </div>
            </div>
        </section>
 
        <section id="basics" class="main-section">
            <div class="header-intro">
                <header>Basics</header>
            </div>
            <div class="container">
                <div class="row">
                    <h1>Variable</h1>
                    <p>A variable is a container for a value, like a number we might use in a sum, or a string that we might use as part of a
                    sentence. But one special thing about variables is that their contained values can change. Let's look at a simple
                    example:</p>
                    <code>var button = document.querySelector('button');</code>
                    <p>Variables just make sense, and as you learn more about JavaScript they will start to become second nature.</p>
                    <p id="basics-intro">Another special thing about variables is that they can contain just about anything — not just strings and numbers.
                    Variables can also contain complex data and even entire functions to do amazing things. You'll learn more about this as
                    you go along.</p><br><hr><br>
                    <h1>Declaring a Variable</h1>
                    <p>To use a variable you've first got to create it — more accurately, we call this declaring the variable. To do this, we
                    type the keyword var followed by the name you want to call your variable:</p>
                    <code>var myName;<br>
                          var myAge;</code>
                    <p>Here we're creating two variables called myName and myAge.</p><br><hr><br>
                    <h1>Initializing a Variable</h1>
                    <p>Once you've declared a variable, you can initialize it with a value. You do this by typing the variable name, followed
                    by an equals sign (=), followed by the value you want to give it.</p>
                    <p>You can declare and initialize a variable at the same time, like this:</p>
                    <code>var myName = 'Sirius';</code>
                    <p>If you write a multiline JavaScript program that declares and initializes a variable, you can actually declare it after
                    you initialize it and it will still work. This is because variable declarations are generally done first before the
                    rest of the code is executed. This is called hoisting — read var hoisting for more detail on the subject.</p><br><hr><br>
                    <h1>Updating a Variable</h1>
                    <p>Once a variable has been initialized with a value, you can change (or update) that value by simply giving it a
                    different value.</p>
                    <code>myName = 'Luna';<br> myAge = 54;</code>
                    <p>You can call a variable pretty much anything you like, but there are limitations. Generally, you should stick to just
                    using Latin characters (0-9, a-z, A-Z) and the underscore character.</p>
                    <ul>
                        <li>You shouldn't use other characters because they may cause errors or be hard to understand for an international
                        audience.</li>
                        <li>Don't use underscores at the start of variable names — this is used in certain JavaScript constructs to mean specific
                        things, so may get confusing.</li>
                        <li>Don't use numbers at the start of variables. This isn't allowed and will cause an error.</li>
                        <li>A safe convention to stick to is so-called "lower camel case", where you stick together multiple words, using lower
                        case for the whole first word and then capitalize subsequent words. We've been using this for our variable names in the
                        article so far.</li>
                        <li>Make variable names intuitive, so they describe the data they contain. Don't just use single letters/numbers, or big
                        long phrases.</li>
                        <li>Variables are case sensitive — so myage is a different variable to myAge.</li>
                        <li>One last point — you also need to avoid using JavaScript reserved words as your variable names — by this, we mean the
                        words that make up the actual syntax of JavaScript! So you can't use words like var, function, let, and for as variable
                        names. Browsers will recognize them as different code items, and so you'll get errors.</li>
                    </ul><br><hr><br>
                    <h1>Numbers and Operators</h1>
                    <p>In programming, even the humble decimal number system that we all know so well is more complicated than you might
                    think. We use different terms to describe different types of decimal numbers, for example:</p>
                    <ul>
                        <li>Integers are whole numbers, e.g. 10, 400, or -5.</li>
                        <li>Floating point numbers (floats) have decimal points and decimal places, for example 12.5, and 56.7786543.</li>
                        <li>Doubles are a specific type of floating point number that have greater precision than standard floating point numbers
                        (meaning that they are accurate to a greater number of decimal places).</li>
                        <p>We even have different types of number systems! Decimal is base 10 (meaning it uses 0–9 in each column), but we also
                        have things like:</p>
                        <ul>
                            <li>Binary — The lowest level language of computers; 0s and 1s.</li>
                            <li>Octal — Base 8, uses 0–7 in each column.</li>
                            <li>Hexadecimal — Base 16, uses 0–9 and then a–f in each column. You may have encountered these numbers before when setting
                            colors in CSS.</li><br><hr><br>
                        </ul>
                    </ul>
                </div>
            </div>
        </section>
        <section id="building-blocks" class="main-section">
            <div class="header-intro">
                <header>Javascript Building Blocks</header>
            </div>
            <div class="container">
                <div class="row">
                    <h1>Conditionals</h1>
                    <p>In any programming language, the code needs to make decisions and carry out actions accordingly depending on different
                    inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is
                    being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article,
                    we'll explore how so-called conditional statements work in JavaScript.</p>
                    <p>Conditional statements allow us to represent such decision making in JavaScript, from the choice that must be made, 
                    to the resulting outcome of those choices</p><br id="bblocks-intro"><hr><br>
                    <h1>If...Else Statements</h1>
                    <p>Basic if...else syntax looks like so in pseudocode:</p>
                    <code>if (condition) { <br> code to run if condition is true <br>} else { <br>run some other code instead <br>} </code>
                    <p>Here we've got:</p>
                    <ol>
                        <li>The keyword if followed by some parentheses.</li>
                        <li>A condition to test, placed inside the parentheses (typically "is this value bigger than this other value", or "does
                        this value exist"). This condition will make use of the comparison operators we discussed in the last module and will
                        return true or false.</li>
                        <li>A set of curly braces, inside which we have some code — this can be any code we like, and will only be run if the
                        condition returns true.</li>
                        <li>The keyword else.</li>
                        <li>Another set of curly braces, inside which we have some more code — this can be any code we like, and will only be run
                        if the condition is not true.</li>
                    </ol><br><hr><br>
                    <h1>Switch Statements</h1>
                    <p>If...else statements do the job of enabling conditional code well, but they are not without their downsides. They are
                    mainly good for cases where you've got a couple of choices, and each one requires a reasonable amount of code to be
                    run, and/or the conditions are complex (e.g. multiple logical operators). For cases where you just want to set a
                    variable to a certain choice of value or print out a particular statement depending on a condition, the syntax can be a
                    bit cumbersome, especially if you've got a large number of choices.</p>
                    <p>Switch statements are your friend here — they take a single expression/value as an input, and then look through a
                    number of choices until they find one that matches that value, executing the corresponding code that goes along with
                    it. Here's some more pseudocode, to give you an idea:</p>
                    <code>switch (expression) { <br>
                           case choice1: <br>
                             run this code <br>
                             break;<br>
                            <br>
                           case choice: <br> 
                             run this code instead <br>
                             break;<br>
                            <br>
                           //include as many cases as you like <br>
                            <br>
                           default: <br>
                             actually just run this code <br>
                         } <br>
                    </code>
                    <p>Here we've got:</p>
                    <ol>
                        <li>The keyword switch, followed by a set of parentheses.</li>
                        <li>An expression or value inside the parentheses.</li>
                        <li>The keyword case, followed by a choice that the expression/value could be, followed by a colon.</li>
                        <li>Some code to run if the choice matches the expression.</li>
                        <li>A break statement, followed by a semi-colon. If the previous choice matches the expression/value, the browser stops
                        executing the code block here, and moves on to any code that appears below the switch statement.</li>
                        <li>As many other cases (bullets 3–5) as you like.</li>
                        <li>The keyword default, followed by exactly the same code pattern as one of the cases (bullets 3–5), except that default
                        does not have a choice after it, and you don't need to break statement as there is nothing to run after this in the
                        block anyway. This is the default option that runs if none of the choices match.</li>
                    </ol>
                    <p>Note: You don't have to include the default section — you can safely omit it if there is no chance that the expression
                    could end up equaling an unknown value. If there is a chance of this, however, you need to include it to handle unknown
                    cases.</p><br><hr><br>
                    <h1>Ternary Operator</h1>
                    <p>There is one final bit of syntax we want to introduce you to before we get you to play with some examples. The ternary
                    or conditional operator is a small bit of syntax that tests a condition and returns one value/expression if it is true,
                    and another if it is false — this can be useful in some situations, and can take up a lot less code than an if...else
                    block if you simply have two choices that are chosen between via a true/false condition. The pseudocode looks like
                    this:</p>
                    <code>( condition ) ? run this code : run this code instead</code>
                    <p>So let's look at a simple example:</p>
                    <code>var greeting = ( isBirthday ) ? 'Happy Birthday Harry Potter - we hope you have a great day!' : 'Good morning Harry Potter!';</code>
                    <p>Here we have a variable called isBirthday — if this is true, we give our guest a happy birthday message; if not, we
                    give him the standard daily greeting.</p>
                    <h1>Loops</h1>
                    <p>Loops, loops, loops. As well as being associated with popular breakfast cereals, roller coasters and musical
                    production, they are also a critical concept in programming. Programming loops are all to do with doing the same thing
                    over and over again — which is termed iteration in programming speak.</p>
                    <p>A loop usually has one or more of the following features:</p>
                    <ul>
                        <li>A counter, which is initialized with a certain value — this is the starting point of the loop ("Start: I have no food",
                        above).</li>
                        <li>An exit condition, which is the criteria under which the loop stops — usually the counter reaching a certain value.
                        This is illustrated by "Have I got enough food?", above. Let's say he needs 10 portions of food to feed his family.</li>
                        <li>An iterator, which generally increments the counter by a small amount on each successive loop, until it reaches the
                        exit condition. We haven't explicitly illustrated this above, but we could think about the farmer being able to collect
                        say 2 portions of food per hour. After each hour, the amount of food he has collected is incremented by two, and he
                        checks whether he has enough food. If he has reached 10 portions (the exit condition), he can stop collecting and go
                        home.</li>
                    </ul><br><hr><br>
                    <h1>The standard for loop</h1>
                    <p>Let's start exploring some specific loop constructs. The first, which you'll use most of the time, is the for loop —
                    this has the following syntax:</p>
                    <code>for (initializer: exit-condition; final expression) { <br>// code to run <br>}</code>
                    <p>Here we have:</p>
                    <ol>
                        <li>The keyword for, followed by some parentheses.</li>
                        <li>Inside the parentheses we have three items, separated by semi-colons:</li>
                            <ul>
                                <li>An initializer — this is usually a variable set to a number, which is incremented to count the number of times the loop
                                has run. It is also sometimes referred to as a counter variable.</li>
                                <li>An exit-condition — as mentioned before, this defines when the loop should stop looping. This is generally an
                                expression featuring a comparison operator, a test to see if the exit condition has been met.</li>
                                <li>A final-expression — this is always evaluated (or run) each time the loop has gone through a full iteration. It usually
                                serves to increment (or in some cases decrement) the counter variable, to bring it closer to the exit condition value.</li>
                            </ul>
                        <li>Some curly braces that contain a block of code — this code will be run each time the loop iterates.</li>
                    </ol><p>In this case, the initializer again comes first, before the loop starts. The do keyword directly precedes the curly
                    braces containing the code to run and the final-expression.</p><br><hr><br> 
                    <h1>Exiting loops with breaks</h1>
                    <p>If you want to exit a loop before all the iterations have been completed, you can use the break statement. We already
                    met this in the previous article when we looked at switch statements — when a case is met in a switch statement that
                    matches the input expression, the break statement immediately exits the switch statement and moves onto the code after
                    it.</p>
                    <p>It's the same with loops — a break statement will immediately exit the loop and make the browser move on to any code
                    that follows it.</p><br><hr><br>
                    <h1>While and do ... while</h1>
                    <p>for is not the only type of loop available in JavaScript. There are actually many others and, while you don't need to
                    understand all of these now, it is worth having a look at the structure of a couple of others so that you can recognize
                    the same features at work in a slightly different way.</p>
                    <p>First, let's have a look at the while loop. This loop's syntax looks like so:</p>
                    <code>initializer <br>while (exit condition) {<br>// code to run <br><br>final-expression <br>}</code>
                    <p>This works in a very similar way to the for loop, except that the initializer variable is set before the loop, and the
                    final-expression is included inside the loop after the code to run — rather than these two items being included inside
                    the parentheses. The exit-condition is included inside the parentheses, which are preceded by the while keyword rather
                    than for.</p>
                    <p>The same three items are still present, and they are still defined in the same order as they are in the for loop — this
                    makes sense, as you still have to have an initializer defined before you can check whether it has reached the
                    exit-condition; the final-condition is then run after the code inside the loop has run (an iteration has been
                    completed), which will only happen if the exit-condition has still not been reached.</p>
                    <p>The do...while loop is very similar, but provides a variation on the while structure:</p>
                    <code>initializer <br>do { <br>// code to run <br><br>final-expression <br>} while (exit-condition)</code>
                    <p>In this case, the initializer again comes first, before the loop starts. The do keyword directly precedes the curly braces containing the code to run and the final-expression.</p>
                    <p>The differentiator here is that the exit-condition comes after everything else, wrapped in parentheses and preceded by
                    a while keyword. In a do...while loop, the code inside the curly braces is always run once before the check is made to
                    see if it should be executed again (in while and for, the check comes first, so the code might never be executed).</p>
                    <p>Important: With while and do...while — as with all loops — you must make sure that the initializer is iterated so that
                    it eventually reaches the exit condition. If not, the loop will go on forever, and either the browser will force it to
                    stop, or it will crash. This is called an infinite loop.</p><br><hr><br>
                    <h1>Functions</h1>
                    <p>Another essential concept in coding is functions, which allow you to store a piece of code that does a single task
                    inside a defined block, and then call that code whenever you need it using a single short command — rather than having
                    to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as
                    basic syntax, how to invoke and define them, scope, and parameters.</p>
                    <p>In JavaScript, you'll find functions everywhere. In fact, we've been using functions all the way through the course so
                    far; we've just not been talking about them very much. Now is the time, however, for us to start talking about
                    functions explicitly, and really exploring their syntax.</p>
                    <p>Pretty much anytime you make use of a JavaScript structure that features a pair of parentheses — () — and you're not
                    using a common built-in language structure like a for loop, while or do...while loop, or if...else statement, you are
                    making use of a function.</p>
                    <h1>Built-in browser functions</h1>
                    <p>We've made use of functions built in to the browser a lot in this course. Every time we manipulated a text string, for
                    example:</p>
                    <code>var myText = 'I am a string';<br>var newString = myText.replace('string', 'sausage');<br>console.log(newString); <br>//the replace() string function takes a string, <br>//replaces one substring with another, and returns
                    <br>//a new string with the replacement made</code>
                    <p>Or every time we manipulated an array:</p>
                    <code>var myArray = ['I', 'love', 'chocolate', 'frogs']; <br>
                          var madeAString = myArray.join(' '); <br>
                          console.log(madeAString);<br>
                          // the join() function takes an array, joins <br>
                          // all the array items together into a single <br>
                          // string, and returns this new string
                    </code>
                    <p>Or every time we generated a random number:</p>
                    <code>var myNumber = Math.random();<br>
                          // the random() function generates a random <br>
                          // the number between 0 and 1, and returns that <br>
                          // number
                    </code>
                    <p>...we were using a function!</p>
                    <p>The JavaScript language has many built-in functions to allow you to do useful things without having to write all that
                    code yourself. In fact, some of the code you are calling when you invoke (a fancy word for run, or execute) a built in
                    browser function couldn't be written in JavaScript — many of these functions are calling parts of the background
                    browser code, which is written largely in low-level system languages like C++, not web languages like JavaScript.</p>
                    <p>Bear in mind that some built-in browser functions are not part of the core JavaScript language — some are defined as
                    part of browser APIs, which build on top of the default language to provide even more functionality (refer to this
                    early section of our course for more descriptions). We'll look at using browser APIs in more detail in a later module.</p><br><hr><br>
                    <h1>Functions versus methods</h1>
                    <p>One thing we need to clear up before we move on — technically speaking, built in browser functions are not functions —
                    they are methods. This sounds a bit scary and confusing, but don't worry — the words function and method are largely
                    interchangeable, at least for our purposes, at this stage in your learning.</p>
                    <p>The distinction is that methods are functions defined inside objects. Built-in browser functions (methods) and
                    variables (which are called properties) are stored inside structured objects, to make the code more efficient and
                    easier to handle.</p>
                    <p>You don't need to learn about the inner workings of structured JavaScript objects yet — you can wait until our later
                    module that will teach you all about the inner workings of objects, and how to create your own. For now, we just wanted
                    to clear up any possible confusion of method versus function — you are likely to meet both terms as you look at the
                    available related resources across the Web.</p><br><hr><br>
                    <h1>Function Parameters</h1>
                    <p>Some functions require parameters to be specified when you are invoking them — these are values that need to be
                    included inside the function parentheses, which it needs to do its job properly.</p>
                    <p>Note: Parameters are sometimes called arguments, properties, or even attributes.</p>
                    <p>As an example, the browser's built-in Math.random() function doesn't require any parameters. When called, it always
                    returns a random number between 0 and 1:</p>
                    <code>var myNumber = Math.random();</code>
                    <p>The browser's built-in string replace() function however needs two parameters — the substring to find in the main
                    string, and the substring to replace that string with:</p>
                    <code>var myText = 'I am a string'; <br>
                          var newString = myText.replace('string', 'sausage');</code>
                    <p>Note: When you need to specify multiple parameters, they are separated by commas.</p>
                    <p>It should also be noted that sometimes parameters are optional — you don't have to specify them. If you don't, the
                    function will generally adopt some kind of default behavior. As an example, the array join() function's parameter is
                    optional:</p>
                    <code>var myArray = ['I', 'love', 'chocolate', 'frogs']; <br>
                          var madeAString = myArray.join(' '); <br>
                          // returns 'I love chocolate frogs' <br>
                          var madeAString = myArray.join(); <br>
                          // returs 'I,love,chocolate,frog'</code>
                    <p>If no parameter is included to specify a joining/delimiting character, a comma is used by default.</p><br><hr><br>
                    <h1>Function scope and conflicts</h1>
                    <p>Let's talk a bit about scope — a very important concept when dealing with functions. When you create a function, the
                    variables and other things defined inside the function are inside their own separate scope, meaning that they are
                    locked away in their own separate compartments, unreachable from inside other functions or from code outside the
                    functions.</p>
                    <p>The top level outside all your functions is called the global scope. Values defined in the global scope are accessible
                    from everywhere in the code.</p>
                    <p>JavaScript is set up like this for various reasons — but mainly because of security and organization. Sometimes you
                    don't want variables to be accessible from everywhere in the code — external scripts that you call in from elsewhere
                    could start to mess with your code and cause problems because they happen to be using the same variable names as other
                    parts of the code, causing conflicts. This might be done maliciously, or just by accident.</p><br><hr><br>
                    <h1>Build your own function</h1>
                    <p>The custom function we are going to build will be called displayMessage(). It will display a custom message box on a
                    web page and will act as a customized replacement for a browser's built-in alert() function. We've seen this before,
                    but let's just refresh our memories. Type the following in your browser's JavaScript console, on any page you like:</p>
                    <code>alert('This is a message');</code>
                    <p>The alert function takes a single argument — the string that is displayed in the alert box. Try varying the string to
                    change the message.</p>
                    <p>The alert function is limited: you can alter the message, but you can't easily vary anything else, such as the color,
                    icon, or anything else. We'll build one that will prove to be more fun.</p><br><hr><br>
                    <h1>The basic function</h1>
                    <p>To begin with, let's put together a basic function.</p>       
                    <p>Note: For function naming conventions, you should follow the same rules as variable naming conventions. This is fine,
                    as you can tell them apart — function names appear with parentheses after them, and variables don't.</p>
                    <ol>
                        <li>Start by accessing the function-start.html file and making a local copy. You'll see that the HTML is simple — the body
                        contains just a single button. We've also provided some basic CSS to style the custom message box, and an empty
                        script element to put our JavaScript in.</li>
                        <li>Next, add the following inside the script element:</li>
                        <code>function displayMessage() {<br>
                        <br><br>}</code>
                        <p>We start off with the keyword function, which means we are defining a function. This is followed by the name we want to
                        give to our function, a set of parentheses, and a set of curly braces. Any parameters we want to give to our function
                        go inside the parentheses, and the code that runs when we call the function goes inside the curly braces.</p>
                        <li>Finally, add the following code inside the curly braces:</li>
                        <code>var html = document.querySelector('html'); <br>
                              <br>
                              var panel = document.createElement('div');<br>
                              panel.setAttribute('class', 'msgBox'); <br>
                              html.appendChild(panel);<br>
                              <br>
                            var closeBtn = document.createElement('button');<br>
                            closeBtn.textContent = 'x';<br>
                            panel.appendChild(closeBtn);<br>
                            <br>
                            closeBtn.onclick = function() { <br>
                            panel.parentNode.removeChild(panel);<br>
                            }
                        </code>
                    </ol>
                    <p>This is quite a lot of code to go through, so we'll walk you through it bit by bit.</p>
                    <p>The first line uses a DOM API function called document.querySelector() to select the html element and store a
                    reference to it in a variable called html, so we can do things to it later on:</p>
                    <code>var html = document.querySelector('html');</code>
                    <p>The next section uses another DOM API function called Document.createElement() to create a div element and store a
                        reference to it in a variable called panel. This element will be the outer container of our message box.</p>
                    <p>We then use yet another DOM API function called Element.setAttribute() to set a class attribute on our panel with a
                    value of msgBox. This is to make it easier to style the element — if you look at the CSS on the page, you'll see that
                    we are using a .msgBox class selector to style the message box and its contents.</p>
                    <p>Finally, we call a DOM function called Node.appendChild() on the html variable we stored earlier, which nests one
                    element inside the other as a child of it. We specify the panel div as the child we want to append inside the html
                        element. We need to do this as the element we created won't just appear on the page on its own — we need to specify
                        where to put it.</p>
                    <code>var panel = document.createElement('div');<br>
                    panel.setAttribute('class', 'msgBox');<br>
                    html.appendChild(panel);</code>
                    <p>The next two sections make use of the same createElement() and appendChild() functions we've already seen to create two
                    new elements — a p and a button — and insert them in the page as children of the panel div. We use their
                    Node.textContent property — which represents the text content of an element — to insert a message inside
                    the paragraph, and an 'x' inside the button. This button will be what needs to be clicked/activated when
                    the user wants to close the message box.</p>
                    <code>var msg = document.createElement('p');<br>
                    msg.textContent = 'This is a message box';<br>
                    panel.appendChild(msg);<br>
                    <br>
                    var closeBtn = document.createElement('button');<br>
                    closeBtn.textContent = 'x';<br>
                    panel.appendChild(closeBtn);</code>
                    <p>Finally, we use an GlobalEventHandlers.onclick event handler to make it so that when the button is clicked, some code
                    is run to delete the whole panel from the page — to close the message box.</p>
                    <p>Briefly, the onclick handler is a property available on the button (or in fact, any element on the page) that can be
                    set to a function to specify what code to run when the button is clicked. You'll learn a lot more about these in our
                    later events article. We are making the onclick handler equal to an anonymous function, which contains the code to run
                    when the button is clicked. The line inside the function uses the Node.removeChild() DOM API function to specify that
                    we want to remove a specific child element of the HTML element — in this case the panel div.</p>
                    <code>closeBtn.onclick = function() {<br>
                    panel.parentNode.removeChild(panel);<br>
                    }</code>
                </div>
            </div>
        </section>
        <section id="objects" class="main-section">
            <div class="header-intro">
                <header>Objects</header>
            </div>
            <div class="container">
                <div class="row">
                    <h1>Objects Basics</h1>
                    <p>An object is a collection of related data and/or functionality (which usually consists of several variables and functions — which are called properties and methods when they are inside objects.) Let's work through an example to understand what they look like.</p>
                    <p>To begin with, make a local copy of our oojs.html file. This contains very little — a script element for us to write our source code into.We'll use this as a basis for exploring basic object syntax. While working with this example you should have your developer tools JavaScript console open and ready to type in some commands.</p>
                    <p>As with many things in JavaScript, creating an object often begins with defining and initializing a variable. Try
                    entering the following below the JavaScript code that's already in your file, then saving and refreshing:</p>
                    <code id="objects-intro">var person = {};</code>
                    <p>If you enter person into your JS console and press the button, you should get the following result:</p>
                    <code>[object Object]</code><br><hr><br>
                    <h1>Dot notation</h1>
                    <p>Above, you accessed the object's properties and methods using dot notation. The object name (person) acts as the
                    namespace — it must be entered first to access anything encapsulated inside the object. Next you write a dot, then the
                    item you want to access — this can be the name of a simple property, an item of an array property, or a call to one of
                    the object's methods, for example:</p>
                    <code>person.age <br>person.interests[1] <br>person.bio()</code>
                    <p>It is even possible to make the value of an object member another object. For example, try changing the name member
                    from</p>
                    <code>name: ['Bob', 'Smith'],</code>
                    <p>to</p>
                    <code>name: { <br>
                            first: 'Bob',<br>
                            last: 'Smith'<br>
                    },
                    </code>
                    <p>Here we are effectively creating a sub-namespace. This sounds complex, but really it's not — to access these items you
                    just need to chain the extra step onto the end with another dot. Try these in the JS console:</p>
                    <code>person.name.first <br>person.name.last</code>
                    <p>Important: At this point you'll also need to go through your method code and change any instances of</p>
                    <code>name[0] <br>name[1]</code>
                    <p>to</p>
                    <code>name.first <br>name.last</code>
                    <p>Otherwise your methods will no longer work.</p><br><hr><br>
                    <h1>Bracket notation</h1>
                    <p>There is another way to access object properties — using bracket notation. Instead of using these:</p>
                    <code>person.age <br>
                    person.name.first</code>
                    <p>You can use</p>
                    <code>person['age'] <br>
                    person['name']['first']</code>
                    <p>This looks very similar to how you access the items in an array, and it is basically the same thing — instead of using
                    an index number to select an item, you are using the name associated with each member's value. It is no wonder that
                    objects are sometimes called associative arrays — they map strings to values in the same way that arrays map numbers to
                    values.</p><br><hr><br>
                    <h1>Setting object members</h1>
                    <p>So far we've only looked at retrieving (or getting) object members — you can also set (update) the value of object
                    members by simply declaring the member you want to set (using dot or bracket notation), like this:</p>
                    <code>person.age = 45;<br>
                    person['name']['last'] = 'Dumbledore';</code>
                    <p>Try entering the above lines, and then getting the members again to see how they've changed, like so:</p>
                    <code>person.age <br>
                    person['name']['last']</code>
                    <p>Setting members doesn't just stop at updating the values of existing properties and methods; you can also create
                    completely new members. Try these in the JS console:</p>
                    <code>person['eyes'] = 'polar lights brown'; <br>
                    person.farewell = function() { alert("Adieu everybody!"); }</code>
                    <p>You can now test out your new members:</p>
                    <code>person['eyes'] <br>
                    person.farewell()</code>
                    <p>One useful aspect of bracket notation is that it can be used to set not only member values dynamically, but member
                    names too. Let's say we wanted users to be able to store custom value types in their people data, by typing the member
                    name and value into two text inputs? We could get those values like this:</p>
                    <code>var myDataName = nameInput.value; <br>
                    var myDataValue = nameValue.value;</code>
                    <p>we could then add this new member name and value to the person object like this:</p>
                    <code>person[myDataName] = myDataValue;</code>
                    <p>To test this, try adding the following lines into your code, just below the closing curly brace of the person object:</p>
                    <code>var myDataName = 'height'; <br>
                    var myDataValue = '1.75m';<br>
                    person[myDataName] = myDataValue;</code>
                    <p>Now try saving and refreshing, and entering the following into your text input:</p>
                    <code>person.height</code>
                    <p>Adding a property to an object using the method above isn't possible with dot notation, which can only accept a literal
                    member name, not a variable value pointing to a name.</p><br><hr><br>
                    <h1>This</h1>
                    <p>You may have noticed something slightly strange in our methods. Look at this one for example:</p>
                    <code>greeting: function() { <br>
                    alert('Hi! I\'m ' + this.name.first + '.');<br>
                    }</code>
                    <p>You are probably wondering what "this" is. The this keyword refers to the current object the code is being written
                    inside — so in this case this is equivalent to person. So why not just write person instead? As you'll see in the
                    Object-oriented JavaScript for beginners article when we start creating constructors, etc., this is very useful — it
                    will always ensure that the correct values are used when a member's context changes (e.g. two different person object
                    instances may have different names, but will want to use their own name when saying their greeting).</p><br><hr><br>
                    <h1>You've been using objects all along</h1>
                    <p>As you've been going through these examples, you have probably been thinking that the dot notation you've been using is
                    very familiar. That's because you've been using it throughout the course! Every time we've been working through an
                    example that uses a built-in browser API or JavaScript object, we've been using objects, because such features are
                    built using exactly the same kind of object structures that we've been looking at here, albeit more complex ones than
                    our own basic custom examples.</p>
                    <p>So when you used string methods like:</p>
                    <code>myString.split(',');</code>
                    <p>You were using a method available on an instance of the String class. Every time you create a string in your code, that
                    string is automatically created as an instance of String, and therefore has several common methods/properties available
                    on it.</p>
                    <p>When you accessed the document object model using lines like this:</p>
                    <code>var myDiv = document.createElement('div');<br>
                    var myVideo = document.querySelector('video');</code>
                    <p>You were using methods available on an instance of the Document class. For each webpage loaded, an instance of Document
                    is created, called document, which represents the entire page's structure, content, and other features such as its URL.
                    Again, this means that it has several common methods/properties available on it.</p>
                    <p>The same is true of pretty much any other built-in object/API you've been using — Array, Math, etc.</p>
                    <p>Note that built in Objects/APIs don't always create object instances automatically. As an example, the Notifications
                    API — which allows modern browsers to fire system notifications — requires you to instantiate a new object instance
                    using the constructor for each notification you want to fire. Try entering the following into your JavaScript console:</p>
                    <code>var myNotification = new Notification('Hello!');</code>
                    <p>Note: It is useful to think about the way objects communicate as message passing — when an object needs another object
                    to perform some kind of action often it will send a message to another object via one of its methods, and wait for a
                    response, which we know as a return value.</p><br><hr><br>
                    <h1>Oject-oriented Javascript</h1>
                    <p>To start with, let's give you a simplistic, high-level view of what Object-oriented programming (OOP) is. We say
                    simplistic, because OOP can quickly get very complicated, and giving it a full treatment now would probably confuse
                    more than help. The basic idea of OOP is that we use objects to model real world things that we want to represent
                    inside our programs, and/or provide a simple way to access functionality that would otherwise be hard or impossible to
                    make use of.</p>
                    <p>Objects can contain related data and code, which represent information about the thing you are trying to model, and
                    functionality or behavior that you want it to have. Object data (and often, functions too) can be stored neatly (the
                    official word is encapsulated) inside an object package (which can be given a specific name to refer to, which is
                    sometimes called a namespace), making it easy to structure and access; objects are also commonly used as data stores
                    that can be easily sent across the network.</p><br><hr><br>
                    <h1>Constructors and object instances</h1>
                    <p>JavaScript uses special functions called constructor functions to define objects and their features. They are useful
                    because you'll often come across situations in which you don't know how many objects you will be creating; constructors
                    provide the means to create as many objects as you need in an effective way, attaching data and functions to them as
                    required.</p>
                    <p>When a new object instance is created from a constructor function, its core functionality (as defined by its prototype,
                    which we'll explore in the article Object prototypes) is linked to via a reference chain called a prototype chain.</p>
                    <p>The constructor function is JavaScript's version of a class. You'll notice that it has all the features you'd expect in
                    a function, although it doesn't return anything or explicitly create an object — it basically just defines properties
                    and methods. You'll see the this keyword being used here as well — it is basically saying that whenever one of these
                    object instances is created, the object's name property will be equal to the name value passed to the constructor call,
                    and the greeting() method will use the name value passed to the constructor call too.</p>
                    <p>Note: A constructor function name usually starts with a capital letter — this convention is used to make constructor
                    functions easier to recognize in code.</p>
                    <p>So how do we call a constructor to create some objects?</p>
                    <ol>
                        <li>Add the following lines below your previous code addition:</li>
                            <code>var person1 = new Person('Bob');<br>
                            var person2 = new Person('Sarah');</code>
                        <li>Save your code and reload it in the browser, and try entering the following lines into your JS console:</li>
                            <code>person1.name <br>
                            person1.greeting() <br>
                            person2.name <br>
                            person2.greeting()</code>
                    </ol>
                    <p>Cool! You'll now see that we have two new objects on the page, each of which is stored under a different namespace —
                    when you access their properties and methods, you have to start calls with person1 or person2; the functionality
                    contained within is neatly packaged away so it won't clash with other functionality. They do, however, have the same
                    name property and greeting() method available. Note that they are using their own name value that was assigned to them
                    when they were created; this is one reason why it is very important to use this, so they will use their own values, and
                    not some other value.</p><br><hr><br>
                    <h1>Object prototypes</h1>
                    <p>JavaScript is often described as a prototype-based language — each object has a prototype object, which acts as a
                    template object that it inherits methods and properties from. An object's prototype object may also have a prototype
                    object, which it inherits methods and properties from, and so on. This is often referred to as a prototype chain, and
                    explains why different objects have properties and methods defined on other objects available to them.</p>
                    <p>Well, to be exact, the properties and methods are defined on the prototype property on the Objects' constructor
                    functions, not the object instances themselves.</p>
                    <p>In JavaScript, a link is made between the object instance and its prototype (its __proto__ property, which is derived
                    from the prototype property on the constructor), and the properties and methods are found by walking up the chain of
                    prototypes.</p>
                    <p>Note: It's important to understand that there is a distinction between an object's prototype (which is available via
                    Object.getPrototypeOf(obj), or via the deprecated __proto__ property) and the prototype property on constructor
                    functions. The former is the property on each instance, and the latter is the property on the constructor. That is,
                    Object.getPrototypeOf(new Foobar()) refers to the same object as Foobar.prototype.</p><br><hr><br>
                    <h1>The prototype property: Where inherited members are defined</h1>
                    <p>So, where are the inherited properties and methods defined? If you look at the Object reference page, you'll see listed
                    in the left hand side a large number of properties and methods — many more than the number of inherited members we saw
                    available on the person1 object in the above screenshot. Some are inherited, and some aren't — why is this?</p>
                    <p>The answer is that the inherited ones are the ones defined on the prototype property (you could call it a
                    sub-namespace) — that is, the ones that begin with Object.prototype., and not the ones that begin with just Object. The
                    prototype property's value is an object, which is basically a bucket for storing properties and methods that we want to
                    be inherited by objects further down the prototype chain.</p>
                    <p>So Object.prototype.watch(), Object.prototype.valueOf(), etc., are available to any object types that inherit from
                    Object.prototype, including new object instances created from the constructor.</p>
                    <p>Object.is(), Object.keys(), and other members not defined inside the prototype bucket are not inherited by object
                    instances or object types that inherit from Object.prototype. They are methods/properties available just on the
                    Object() constructor itself.</p>
                    <p>Note: This seems strange — how can you have a method defined on a constructor, which is itself a function? Well, a
                    function is also a type of object — see the Function() constructor reference if you don't believe us.</p>
                    <ol>
                        <li>You can check out existing prototype properties for yourself — go back to our previous example and try entering the
                        following into the JavaScript console:</li>
                        <code>Person.prototype</code>
                        <li>The output won't show you very much — after all, we haven't defined anything on our custom constructor's prototype! By
                        default, a constructor's prototype always starts empty. Now try the following:</li>
                        <code>Object.prototype</code>
                    </ol>
                    <p>You'll see a large number of methods defined on Object's prototype property, which are then available on objects that
                    inherit from Object, as shown earlier.</p>
                    <p>You'll see other examples of prototype chain inheritance all over JavaScript — try looking for the methods and
                    properties defined on the prototype of the String, Date, Number, and Array global objects, for example. These all have
                    a number of members defined on their prototype, which is why for example when you create a string, like this:</p>
                    <code>var myString = 'This is my string.';</code>
                    <p>myString immediately has a number of useful methods available on it, like split(), indexOf(), replace(), etc.</p>
                    <p>Note: It is worth reading our more in-depth guide to Using prototypes in JavaScript, once you've make sense of this
                    section and wish to know more. This section is intentionally simplified to make these concepts a little easier to
                    understand when you first meet them.</p>
                    <p>Important: The prototype property is one of the most confusingly-named parts of JavaScript — you might think that this
                    points to the prototype object of the current object, but it doesn't (that's an internal object that can be accessed by
                    __proto__, remember?). prototype instead is a property containing an object on which you define members that you want
                    to be inherited.</p><br><hr><br>
                    <h1>Working with JSON</h1>
                    <p>JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript
                    object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server
                    to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this
                    article we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data
                    within it, and creating JSON.</p>
                    <p>JSON is a text-based data format following JavaScript object syntax, which was popularized by Douglas Crockford. Even
                    though it closely resembles JavaScript object literal syntax, it can be used independently from JavaScript, and many
                    programming environments feature the ability to read (parse) and generate JSON.</p>
                    <p>JSON exists as a string — useful when you want to transmit data across a network. It needs to be converted to a native
                    JavaScript object when you want to access the data. This is not a big issue — JavaScript provides a global JSON object
                    that has methods available for converting between the two.</p>
                    <p>Note: Converting a string to a native object is called parsing, while converting a native object to a string so it can
                    be transmitted across the network is called stringification.</p>
                    <p>A JSON object can be stored in its own file, which is basically just a text file with an extension of .json, and a MIME
                    type of application/json.</p>
                    <p>As described above, a JSON is a string whose format very much resembles JavaScript object literal format. You can
                    include the same basic data types inside JSON as you can in a standard JavaScript object — strings, numbers, arrays,
                    booleans, and other object literals.</p>
                    <p>If we loaded this object into a JavaScript program, parsed in a variable called superHeroes for example, we could then
                    access the data inside it using the same dot/bracket notation we looked at in the JavaScript object basics article. For
                    example:</p>
                    <code>superHeroes.homeTown <br>
                    superHeroes['active']</code>
                    <p>To access data further down the hierarchy, you simply have to chain the required property names and array indexes
                    together. For example, to access the third superpower of the second hero listed in the members list, you'd do this:</p>
                    <code>superHeroes['members'][1]['powers'][2]</code>
                    <ol>
                        <li>First we have the variable name — superHeroes.</li>
                        <li>Inside that we want to access the members property, so we use ["members"].</li>
                        <li>members contains an array populated by objects. We want to access the second object inside the array, so we use [1].</li>
                        <li>Inside this object, we want to access the powers property, so we use ["powers"].</li>
                        <li>Inside the powers property is an array containing the selected hero's superpowers. We want the third one, so we use
                        [2].</li>
                    </ol>
                    <p>Note: We've made the JSON seen above available inside a variable in our JSONTest.html example (see the source code).
                    Try loading this up and then accessing data inside the variable via your browser's JavaScript console.</p>
                    <p>Other Notes:</p>
                    <ul>
                        <li>JSON is purely a data format — it contains only properties, no methods.</li>
                        <li>JSON requires double quotes to be used around strings and property names. Single quotes are not valid.</li>
                        <li>Even a single misplaced comma or colon can cause a JSON file to go wrong, and not work. You should be careful to
                        validate any data you are attempting to use (although computer-generated JSON is less likely to include errors, as long
                        as the generator program is working correctly). You can validate JSON using an application like JSONLint.</li>
                        <li>JSON can actually take the form of any data type that is valid for inclusion inside JSON, not just arrays or objects.
                        So for example, a single string or number would be a valid JSON object.</li>
                        <li>Unlike in JavaScript code in which object properties may be unquoted, in JSON, only quoted strings may be used as
                        properties.</li>
                    </ul>

                </div>
            </div>
        </section>
        <section id="client-side" class="main-section">
            <div class="header-intro">
                <header>Client-side Web APIs</header>
            </div>
            <div class="container">
                <div class="row">
                    <h1>What are APIs?</h1>
                    <p>Application Programming Interfaces (APIs) are constructs made available in programming languages to allow developers to
                    create complex functionality more easily. They abstract more complex code away from you, providing some easier syntax
                    to use in its place.</p>
                    <p>As a real-world example, think about the electricity supply in your house, apartment, or other dwellings. If you want
                    to use an appliance in your house, you simply plug it into a plug socket and it works. You don't try to wire it
                    directly into the power supply — to do so would be really inefficient and, if you are not an electrician, difficult and
                    dangerous to attempt.</p>
                    <p id="client-intro">In the same way, if you want to say, program some 3D graphics, it is a lot easier to do it using an API written in a
                    higher level language such as JavaScript or Python, rather than try to directly write low level code (say C or C++)
                    that directly controls the computer's GPU or other graphics functions.</p><br><hr><br>
                    <h1>APIs in client-side JavaScript</h1>
                    <p>Client-side JavaScript, in particular, has many APIs available to it — these are not part of the JavaScript language
                    itself, rather they are built on top of the core JavaScript language, providing you with extra superpowers to use in
                    your JavaScript code. They generally fall into two categories:</p>
                    <ul>
                        <li><strong>Browser APIs</strong> are built into your web browser and are able to expose data from the browser and surrounding computer
                        environment and do useful complex things with it. For example, the Geolocation API provides some simple JavaScript
                        constructs for retrieving location data so you can, for example, plot your location on a Google Map. In the background,
                        the browser is actually using some complex lower-level code (e.g. C++) to communicate with the device's GPS hardware
                        (or whatever is available to determine position data), retrieve position data, and return it to the browser environment
                        for use in your code. But again, this complexity is abstracted away from you by the API.</li>
                        <li><strong>Third party APIs</strong> are not built into the browser by default, and you generally have to retrieve their code and
                        information from somewhere on the Web. For example, the Twitter API allows you to do things like displaying your latest
                        tweets on your website. It provides a special set of constructs you can use to query the Twitter service and return
                        specific information.</li>
                    </ul><br><hr><br>
                    <h1>Relationship between JavaScript, APIs, and other JavaScript tools</h1>
                    <p>So above, we talked about what client-side JavaScript APIs are, and how they relate to the JavaScript language. Let's
                    recap this to make it clearer, and also mention where other JavaScript tools fit in:</p>
                    <ul>
                        <li>JavaScript — A high-level scripting language built into browsers that allows you to implement functionality on web
                        pages/apps. Note that JavaScript is also available in other programming environments, such as Node.</li>
                        <li>Browser APIs — constructs built into the browser that sit on top of the JavaScript language and allow you to implement
                        functionality more easily.</li>
                        <li>Third party APIs — constructs built into third-party platforms (e.g. Twitter, Facebook) that allow you to use some of
                        those platform's functionality in your own web pages (for example, display your latest Tweets on your web page).</li>
                        <li>JavaScript libraries — Usually one or more JavaScript files containing custom functions that you can attach to your web
                        page to speed up or enable writing common functionality. Examples include jQuery, Mootools and React.</li>
                        <li>JavaScript frameworks — The next step up from libraries, JavaScript frameworks (e.g. Angular and Ember) tend to be
                        packages of HTML, CSS, JavaScript, and other technologies that you install and then use to write an entire web
                        application from scratch. The key difference between a library and a framework is “Inversion of Control”. When calling
                        a method from a library, the developer is in control. With a framework, the control is inverted: the framework calls
                        the developer's code.</li>
                    </ul><br><hr><br>
                    <h1>What APIs can do?</h1>
                    <p>There are a huge number of APIs available in modern browsers that allow you to do a wide variety of things in your
                    code. You can see this by taking a look at the <a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank">MDN APIs index page.</a></p><br><hr><br>
                    <h1>Common Browser APIs</h1>
                    <p>In particular, the most common categories of browser APIs you'll use (and which we'll cover in this module in greater
                    detail) are:</p>
                    <ul>
                        <li><strong>APIs for manipulating documents</strong> loaded into the browser. The most obvious example is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">DOM (Document Object Model)
                        API</a>, which allows you to manipulate HTML and CSS — creating, removing and changing HTML, dynamically applying new
                        styles to your page, etc. Every time you see a popup window appear on a page, or some new content displayed, for
                        example, that's the DOM in action. Find out more about these types of API in <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents">Manipulating documents</a>.</li>
                        <li><strong>APIs that fetch data from the server</strong> to update small sections of a webpage on their own are very commonly used. This
                        seemingly small detail has had a huge impact on the performance and behaviour of sites — if you just need to update a
                        stock listing or list of available new stories, doing it instantly without having to reload the whole entire page from
                        the server can make the site or app feel much more responsive and "snappy". APIs that make this possible include
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>. You may also come across the term <strong>Ajax</strong>, which describes this technique. Find out more
                        about such APIs in <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data">Fetching data from the server</a>.</li>
                        <li><strong>APIs for drawing and manipulating graphics</strong> are now widely supported in browsers — the most popular ones are <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a>, which allow you to programmatically update the pixel data contained in an HTML canvas element to create 2D and 3D scenes. For example, you might draw shapes such as rectangles or circles, import an image onto the canvas, and apply a filter to it such as sepia or grayscale using the Canvas API, or create a complex 3D scene with lighting and textures using WebGL. Such APIs are often combined with APIs for creating animation loops (such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame">window.requestAnimationFrame()</a>) and others to make constantly updating scenes like cartoons and games.</li>
                        <li><strong>Audio and Video APIs</strong> like <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement">HTMLMediaElement</a>, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">WebRTC</a> allow you to do really interesting things with multimedia such as creating custom UI controls for playing audio and video, displaying text tracks like captions and subtitles along with your videos, grabbing video from your web camera to be manipulated via a canvas (see above) or displayed on someone else's computer in a web conference, or adding effects to audio tracks (such as gain, distortion, panning, etc).</li>
                        <li><strong>Device APIs</strong> are basically APIs for manipulating and retrieving data from modern device hardware in a way that is useful for web apps. We've already talked about the Geolocation API accessing the device's location data so you can plot your position on a map. Other examples include telling the user that a useful update is available on a web app via system notifications (see the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API">Notifications API</a>) or vibration hardware (see the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API">Vibration API</a>).</li>
                        <li><strong>Client-side storage APIs</strong> are becoming a lot more widespread in web browsers — the ability to store data on the client-side is very useful if you want to create an app that will save its state between page loads, and perhaps even work when the device is offline. There are a number of options available, e.g. simple name/value storage with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage API</a>, and more complex tabular data storage with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB API</a>.</li><br><hr><br>
                    </ul>
                    <h1>Common Third-Party APIs</h1>
                    <p>Third party APIs come in a large variety; some of the more popular ones that you are likely to make use of sooner or
                    later are:</p>
                    <ul>
                        <li>The <a href="https://developer.twitter.com/en/docs">Twitter API</a>, which allows you to do things like displaying your latest tweets on your website.</li>
                        <li>The <a href="https://cloud.google.com/maps-platform/">Google Maps API</a> allows you to do all sorts of things with maps on your web pages (funnily enough, it also powers Google Maps). This is now an entire suite of APIs, which handle a wide variety of tasks, as evidenced by the <a href="https://developers.google.com/maps/documentation/api-picker">Google Maps API Picker</a>.</li>
                        <li>The <a href="https://developers.facebook.com/docs/">Facebook suite of APIs</a> enables you to use various parts of the Facebook ecosystem to benefit your app, for example by providing app login using Facebook login, accepting in-app payments, rolling out targetted ad campaigns, etc.</li>
                        <li>The <a href="https://developers.google.com/youtube/">YouTube API</a>, which allows you to embed YouTube videos on your site, search YouTube, build playlists, and more.</li>
                        <li>The <a href="https://www.twilio.com/">Twilio API</a>, which provides a framework for building voice and video call functionality into your app, sending SMS/MMS from your apps, and more.</li>
                    </ul><br><hr><br>
                    <h1>How do API's work?</h1>
                    <p>Different JavaScript APIs work in slightly different ways, but generally, they have common features and similar themes
                    to how they work.</p>
                    <h1>They are based on Objects</h1>
                    <p>Your code interacts with APIs using one or more <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects">JavaScript objects</a>, which serve as containers for the data the API uses
                    (contained in object properties), and the functionality the API makes available (contained in object methods).</p>
                    <p>Let's return to the example of the Geolocation API — this is a very simple API that consists of a few simple objects:</p>
                    <ul>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation">Geolocation</a>, which contains three methods for controlling the retrieval of geodata.</li>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Position">Position</a>, which represents the position of a device at a given time — this contains a Coordinates object that contains the actual position information, plus a timestamp representing the given time.</li>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Coordinates">Coordinates</a>, which contains a whole lot of useful data on the device position, including latitude and longitude, altitude, velocity and direction of movement, and more.</li>
                    </ul><br><hr><br>
                    <h1>They have recognizable entry points</h1>
                    <p>When using an API, you should make sure you know where the entry point is for the API. In The Geolocation API, this is pretty simple — it is the Navigator.geolocation property, which returns the browser's Geolocation object that all the useful geolocation methods are available inside.</p>
                    <p>The Document Object Model (DOM) API has an even simpler entry point — its features tend to be found hanging off the Document object, or an instance of an HTML element that you want to affect in some way, for example:</p>
                    <code>var em = document.createElement('em'); // create a new em element <br>
                          var para = document.querySelector('p'); // reference an existing p element <br>
                          em.textContent = 'Hello there!'; // give em some text content<br>
                          para.appendChild(em); // embed em inside para</code>
                    <p>Other APIs have slightly more complex entry points, often involving creating a specific context for the API code to be written in. For example, the Canvas API's context object is created by getting a reference to the canvas element you want to draw on, and then calling its HTMLCanvasElement.getContext() method:</p>
                    <code>var canvas = document.querySelector('canvas'); <br>
                          var ctx = canvas.getContext('2d');</code><br><hr><br>
                    <h1>The Important Parts of a Web Browser</h1>
                    <p>Web browsers are very complicated pieces of software with a lot of moving parts, many of which can't be controlled or
                    manipulated by a web developer using JavaScript. You might think that such limitations are a bad thing, but browsers
                    are locked down for good reasons, mostly centering around security. Imagine if a web site could get access to your
                    stored passwords or other sensitive information, and log into websites as if it were you?</p><br><hr><br>
                    <h1>The document object model</h1>
                    <p>The document currently loaded in each one of your browser tabs is represented by a document object model. This is a
                    "tree structure" representation created by the browser that enables the HTML structure to be easily accessed by
                    programming languages — for example the browser itself uses it to apply styling and other information to the correct
                    elements as it renders a page, and developers like you can manipulate the DOM with JavaScript after the page has been
                    rendered.</p>
                    <p>The DOM on the other hand looks like this:</p>
                    <img src="img/dom.png" alt="" style="margin-left: 50px;">
                    <p>You can see here that each element and bit of text in the document has its own entry in the tree — each one is called a
                    node. You will also encounter various terms used to describe the type of node, and their position in the tree in
                    relation to one another:</p>
                    <ul>
                        <li>Element node: An element, as it exists in the DOM.</li>
                        <li>Root node: The top node in the tree, which in the case of HTML is always the HTML node (other markup vocabularies like
                        SVG and custom XML will have different root elements).</li>
                        <li>Child node: A node directly inside another node. For example, IMG is a child of SECTION in the above example.</li>
                        <li>Descendant node: A node anywhere inside another node. For example, IMG is a child of SECTION in the above example, and
                        it is also a descendant. IMG is not a child of BODY, as it is two levels below it in the tree, but it is a descendant
                        of BODY.</li>
                        <li>Parent node: A node which has another node inside it. For example, BODY is the parent node of SECTION in the above
                        example.</li>
                        <li>Sibling nodes: Nodes that sit on the same level in the DOM tree. For example, IMG and P are siblings in the above
                        example.</li>
                        <li>Text node: A node containing a text string.</li>
                    </ul>
                    <p>It is useful to familiarize yourself with this terminology before working with the DOM, as a number of the code terms
                    you'll come across make use of them. You may have also come across them if you have studied CSS (e.g. descendant
                    selector, child selector).</p><br><hr><br>
                    <h1>Active learning: Basic DOM Manipulation</h1>
                    <p>To start learning about DOM manipulation, let's begin with a practical example.</p>
                    <ol>
                        <li>Take a local copy of the dom-example.html page and the image that goes along with it.</li>
                        <li>Add a script element just above the closing body tag.</li>
                        <li>To manipulate an element inside the DOM, you first need to select it and store a reference to it inside a variable.
                        Inside your script element, add the following line:</li>
                        <code>var link = document.querySelector('a');</code>
                        <li>Now we have the element reference stored in a variable, we can start to manipulate it using properties and methods
                        available to it (these are defined on interfaces like HTMLAnchorElement in the case of a element, its more general
                            parent interface HTMLElement, and Node — which represents all nodes in a DOM). First of all, let's change the text
                            inside the link by updating the value of the Node.textContent property. Add the following line below the previous
                            one:</li>
                        <code>link.textContent = 'Mozilla Developer Network';</code>
                        <li>We should also change the URL the link is pointing to, so that it doesn't go to the wrong place when it is clicked on.
                        Add the following line, again at the bottom:</li>
                        <code>link.href = 'https://developer.mozilla.org';</code>
                    </ol>
                    <p>Note that, as with many things in JavaScript, there are many ways to select an element and store a reference to it in a
                    variable. Document.querySelector() is the recommended modern approach, which is convenient because it allows you to
                    select elements using CSS selectors. The above querySelector() call will match the first a element that appears in
                        the document. If you wanted to match and do things to multiple elements, you could use Document.querySelectorAll(),
                        which matches every element in the document that matches the selector, and stores references to them in an
                        array-like object called a NodeList.</p>
                    <p>There are older methods available for grabbing element references, such as:</p>
                    <ul>
                        <li>Document.getElementById(), which selects an element with a given id attribute value, 
                        The ID is passed to the function as a parameter, i.e. var elementRef = document.getElementById('myId').</li>
                        <li>Document.getElementsByTagName(), which returns an array containing all the elements on the page of a given type, for
                        example p's,a's, etc. The element type is passed to the function as a parameter, i.e. var elementRefArray =
                        document.getElementsByTagName('p').</li>
                    </ul><br><hr><br>
                    <h1>Fetching data from the server</h1>
                    <p>Another very common task in modern websites and applications is retrieving individual data items from the server to
                    update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge
                    impact on the performance and behavior of sites, so in this article we'll explain the concept and look at technologies
                    that make it possible, such as XMLHttpRequest and the Fetch API.</p>
                    <p>Originally page loading on the web was simple — you'd send a request for a web site to a server, and as long as nothing
                    went wrong, the assets that made the web page would be downloaded and displayed on your computer.</p>
                    <p>The trouble with this model is that whenever you want to update any part of the page, for example to display a new set
                    of products or load a new page, you've got to load the entire page again. This is extremely wasteful and results in a
                    poor user experience, especially as pages get larger and more complex.</p><br><hr><br>
                    <h1>Ajax</h1>
                    <p>This led to the creation of technologies that allow web pages to request small chunks of data (such as HTML, XML, JSON,
                    or plain text) and display them only when needed, helping to solve the problem described above.</p>
                    <p>This is achieved by using APIs like XMLHttpRequest or — more recently — the Fetch API. These technologies allow web
                    pages to directly handle making HTTP requests for specific resources available on a server, and formatting the
                    resulting data as needed, before it is displayed.</p>
                    <p>The Ajax model involves using a web API as a proxy to more intelligently request data rather than just having the
                    browser to reload the entire page. Let's think about the significance of this:</p>
                    <ol>
                        <li>Go to one of your favorite information-rich sites, like Amazon, YouTube, CNN, etc., and load it.</li>
                        <li>Now search for something, like a new product. The main content will change, but most of the surrounding information,
                        like the header, footer, navigation menu, etc., will stay the same.</li>
                    </ol>
                    <p>This is a really good thing because:</p>
                    <ul>
                        <li>Page updates are a lot quicker and you don't have to wait for the page to refresh, meaning that the site feels faster
                        and more responsive.</li>
                        <li>Less data is downloaded on each update, meaning less wasted bandwidth. This may not be such a big issue on a desktop on
                        a broadband connection, but it's a major issue on mobile devices and in developing countries that don't have ubiquitous
                        fast Internet service.</li>
                    </ul>
                    <p>To speed things up even further, some sites also store assets and data on the user's computer when they are first
                    requested, meaning that on subsequent visits they use the local versions instead of downloading fresh copies when the
                    page is first loaded. The content is only reloaded from the server when it has been updated.</p><br><hr><br>
                    <h1>Third-Party APIs</h1>
                    <p>Third party APIs are APIs provided by third parties — generally companies such as Facebook, Twitter, or Google — to
                    allow you to access their functionality via JavaScript and use it on your own site. As we showed in our introductory
                    APIs article, one of the most obvious examples is using the Google Maps APIs to display custom maps on your pages.</p>
                    <p>Note: By default, using third-party APIs on your site will allow them to track with their own domain cookies, set
                    cookies on your origin, obtain referer headers identifying the pages users visit and allow them to execute JavaScript
                    on the pages they are loaded on with the same origin permissions (for example, execute AJAX requests to your servers
                    with same session cookies). Regulatory, security, and privacy implications should be assessed. Mitigations of default
                    security risks are sometimes possible, but will likely require support from a specialist in web security.</p>
                    <p>Browser APIs are built into the browser — you can access them from JavaScript immediately. For example, the Geolocation
                    API used in our example is accessed using the geolocation property of the Navigator object, which returns a Geolocation
                    object. This example uses the getCurrentPosition() method of this object to request the device's current position:</p>
                    <code>navigator.geolocation.getCurrentPosition(function(position) { ... });</code>
                    <p>Third party APIs, on the other hand, are located on third party servers. To access them from JavaScript you first need
                    to connect to the API functionality and make it available on your page. This typically involves first linking to a
                    JavaScript library available on the server via a
                    script element.</p>
                    <p>Security for browser APIs tends to be handled by permission prompts, as discussed in our first article. The purpose of
                    these is so that the user knows what is going on in the websites they visit and is less likely to fall victim to
                    someone using an API in a malicious way.</p>
                    <p>Third party APIs have a slightly different permissions system — they tend to use key codes to allow developers access
                    to the API functionality. Look again at the URL of the Google Maps API library we linked to:</p>
                    <code>https://maps.google.com/maps/api/js?key=AIzaSyDDuGt0E5IEGkcE6ZfrKfUtE9Ko_de66pA</code>
                    <p>The URL parameter provided at the end of the URL is a developer key — the developer of the application must apply to
                    get a key, and then include it in their code in a specific way to be allowed access to the API's functionality. In the
                    case of Google Maps (and other Google APIs), you apply for a key at the Google Cloud Platform.</p>
                    <p>Other APIs may require that you include the key in a slightly different way, but the pattern is fairly similar for most
                    of them.</p>
                    <p>The point of requiring a key is so that not just anybody can use API functionality without any kind of accountability.
                    When the developer has registered for a key, they are then known to the API provider, and action can be taken if they
                    start to do anything malicious with the API (such as tracking people's location or trying to spam the API with loads of
                    requests to stop it working, for example). The easiest action would be to just revoke their API privileges.</p><br><hr><br>
                    <h1>Client-side storage</h1>
                    <p>Elsewhere in the MDN learning area we talked about the difference between static sites and dynamic sites. Most major
                    modern web sites are dynamic — they store data on the server using some kind of database (server-side storage), then
                    run server-side code to retrieve needed data, insert it into static page templates, and serve the resulting HTML to the
                    client to be displayed by the user's browser.</p>
                    <p>Client-side storage works on similar principles, but has different uses. It consists of JavaScript APIs that allow you
                    to store data on the client (i.e. on the user's machine) and then retrieve it when needed. This has many distinct uses,
                    such as:</p>
                    <ul>
                        <li>Personalizing site preferences (e.g. showing a user's choice of custom widgets, color scheme, or font size).</li>
                        <li>Persisting previous site activity (e.g. storing the contents of a shopping cart from a previous session, remembering if
                        a user was previously logged in).</li>
                        <li>Saving data and assets locally so a site will be quicker (and potentially less expensive) to download, or be usable
                        without a network connection.</li>
                        <li>Saving web application generated documents locally for use offline</li>
                    </ul><br>
                    <div class="back-top">
                    <a href="#introduction">Back To Top</a>
                    </div>
                </div>
            </div>
        </section>    
    </main>
    
    <script src="script.js"></script>
</body>
</html>